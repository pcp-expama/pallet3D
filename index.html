<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Palete 3D - PCP</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e9ecef;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #painel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 310px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 10;
        }
        #painel h3 {
            margin-top: 0;
            color: #333;
            font-size: 15px;
            border-bottom: 2px solid #6a82b8;
            padding-bottom: 5px;
        }
        .linha-input {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
        }
        .linha-input label {
            font-size: 13px;
            color: #555;
            font-weight: 500;
        }
        .linha-input input[type="number"] {
            width: 75px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: right;
            font-family: monospace;
            font-size: 13px;
        }
        .linha-input input[type="text"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            margin-top: 5px;
            text-transform: uppercase;
        }
        .input-bloco {
            margin-bottom: 8px;
        }
        .input-bloco label {
            font-size: 13px;
            color: #555;
            font-weight: 500;
            display: block;
        }
        .resultado {
            margin-top: 15px;
            padding: 12px 10px;
            background-color: #e3f2fd;
            border-left: 4px solid #1976d2;
            color: #0d47a1;
            font-size: 14px;
            border-radius: 0 4px 4px 0;
            line-height: 1.6;
        }
        .resultado b {
            color: #002171;
        }
        .resultado hr {
            border: 0;
            border-top: 1px solid #bbdefb;
            margin: 8px 0;
        }
        button {
            width: 100%;
            padding: 12px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
            font-size: 13px;
        }
        .btn-atualizar {
            background-color: #6a82b8;
            margin-top: 15px;
        }
        .btn-atualizar:hover { background-color: #536b9e; }
        
        .btn-fila {
            background-color: #f57c00;
        }
        .btn-fila:hover { background-color: #e65100; }
        
        .btn-limpar {
            background-color: #c62828;
        }
        .btn-limpar:hover { background-color: #b71c1c; }

        .btn-pdf {
            background-color: #2e7d32; 
            margin-top: 10px;
        }
        .btn-pdf:hover { background-color: #1b5e20; }
        
        .botoes-fila {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="painel">
        <h3>Dados do Relatório</h3>
        <div class="input-bloco">
            <label>Nome do Produto:</label>
            <input type="text" id="nome_produto" value="PEÇAS CORTADAS DE MDF">
        </div>

        <h3 style="margin-top: 15px;">Dimensões do Pontalete</h3>
        <div class="linha-input"><label>Largura X (m):</label><input type="number" step="0.001" id="b_larg" value="0.080"></div>
        <div class="linha-input"><label>Compr. Z (m):</label><input type="number" step="0.001" id="b_comp" value="1.850"></div>
        <div class="linha-input"><label>Altura Y (m):</label><input type="number" step="0.001" id="b_alt" value="0.070"></div>
        <div class="linha-input"><label>Recuo Bordas (m):</label><input type="number" step="0.001" id="b_recuo" value="0.150"></div>

        <h3 style="margin-top: 15px;">Dimensões do Forro</h3>
        <div class="linha-input"><label>Largura X (m):</label><input type="number" step="0.001" id="f_larg" value="1.850"></div>
        <div class="linha-input"><label>Compr. Z (m):</label><input type="number" step="0.001" id="f_comp" value="2.750"></div>
        <div class="linha-input"><label>Espessura Y (m):</label><input type="number" step="0.001" id="f_alt" value="0.015"></div>

        <h3 style="margin-top: 15px;">Dimensões do Produto</h3>
        <div class="linha-input"><label>Largura X (m):</label><input type="number" step="0.001" id="p_larg" value="0.45"></div>
        <div class="linha-input"><label>Compr. Z (m):</label><input type="number" step="0.001" id="p_comp" value="1.36"></div>
        <div class="linha-input"><label>Espessura Y (m):</label><input type="number" step="0.001" id="p_alt" value="0.006"></div>

        <h3 style="margin-top: 15px;">Empilhamento</h3>
        <div class="linha-input"><label>Qtd. Camadas:</label><input type="number" id="camadas" value="120"></div>

        <div class="resultado" id="resultado-dados">
        </div>

        <button class="btn-atualizar" onclick="window.atualizarPalete()">Atualizar Simulação</button>
        
        <div class="botoes-fila">
            <button class="btn-fila" style="flex: 2;" onclick="window.adicionarFila()">+ Add Fila PDF (<span id="contador_pdf">0</span>/3)</button>
            <button class="btn-limpar" style="flex: 1;" onclick="window.limparFila()">Limpar</button>
        </div>
        
        <button class="btn-pdf" onclick="window.gerarPDF()">Gerar PDF Comparativo</button>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Cena e Câmera
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe9ecef); 

        const gridHelper = new THREE.GridHelper(10, 50, 0xcccccc, 0xdddddd);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 5); 

        // 2. Renderizador em Alta Qualidade (alpha: true permite fundo transparente para recorte perfeito)
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // 3. Iluminação
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 8, 3);
        dirLight.castShadow = true;
        
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 20;
        dirLight.shadow.camera.left = -4;
        dirLight.shadow.camera.right = 4;
        dirLight.shadow.camera.top = 4;
        dirLight.shadow.camera.bottom = -4;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.2);
        fillLight.position.set(-5, 3, -5);
        scene.add(fillLight);

        // Grupo principal
        const grupoPalete = new THREE.Group();
        scene.add(grupoPalete);

        // 4. Materiais
        const matBarrote = new THREE.MeshLambertMaterial({ color: 0x2b3a5e }); 
        const matForro = new THREE.MeshLambertMaterial({ color: 0xc4b7a6 });   
        const matProduto = new THREE.MeshLambertMaterial({ color: 0x829a88 }); 
        const matLinha = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 1 });

        function adicionarContorno(mesh) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, matLinha);
            mesh.add(line);
        }

        // --- SISTEMA DE CORTE ABSOLUTO (FUNDO TRANSPARENTE) ---
        function cortarImagem(dataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let top = null, bottom = null, left = null, right = null;
                    
                    // Como a foto foi tirada sem fundo, basta procurar por pixels não-transparentes (alpha > 5)
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const alpha = data[(y * canvas.width + x) * 4 + 3];
                            if (alpha > 5) { // Se não é transparente, faz parte do palete
                                if (top === null) top = y;
                                bottom = y;
                                if (left === null || x < left) left = x;
                                if (right === null || x > right) right = x;
                            }
                        }
                    }
                    
                    if (top === null) { 
                        resolve({ url: dataUrl, width: img.width, height: img.height }); 
                        return; 
                    } 
                    
                    // Margem ZERO. A imagem ficará do tamanho exato da madeira.
                    const padding = 0;
                    const cropW = (right - left) + padding * 2;
                    const cropH = (bottom - top) + padding * 2;
                    
                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = cropW;
                    cropCanvas.height = cropH;
                    const cropCtx = cropCanvas.getContext('2d');
                    
                    // Adicionando um fundo branco por trás da imagem cortada para ficar perfeito no PDF
                    cropCtx.fillStyle = '#ffffff';
                    cropCtx.fillRect(0, 0, cropW, cropH);
                    cropCtx.drawImage(canvas, left, top, right - left, bottom - top, padding, padding, right - left, bottom - top);
                    
                    resolve({
                        url: cropCanvas.toDataURL('image/png'),
                        width: cropW,
                        height: cropH
                    });
                };
                img.src = dataUrl;
            });
        }

        // --- SISTEMA DE FILA PARA O PDF MÚLTIPLO ---
        window.filaPDF = [];
        window.dadosRelatorio = { totalPecas: 0, volTotal: 0 };

        window.adicionarFila = async function() {
            if (window.filaPDF.length >= 3) {
                alert("A fila já contém 3 simulações! Gere o relatório ou limpe a fila.");
                return;
            }

            // MÁGICA DO ESTÚDIO: Tira a grade e o fundo, bate a foto, e devolve sem o usuário perceber.
            const bgOriginal = scene.background;
            scene.background = null; // Transparente
            gridHelper.visible = false; // Esconde a grade do chão
            
            renderer.render(scene, camera);
            const imgDataEstudio = renderer.domElement.toDataURL('image/png');
            
            // Retorna o visual ao normal
            scene.background = bgOriginal;
            gridHelper.visible = true;
            renderer.render(scene, camera);

            // Corta a foto de estúdio isolando apenas a madeira
            const imgCortada = await cortarImagem(imgDataEstudio);

            const pLarg = parseFloat(document.getElementById('p_larg').value);
            const pCompStr = document.getElementById('p_comp').value.trim();
            const pEspStr = document.getElementById('p_alt').value.trim();

            const largFormatada = Number((pLarg * 100).toFixed(2)).toString().replace('.', ',');
            const compFormatada = pCompStr.replace('.', ',');
            const espFormatada = pEspStr.replace('.', ',');

            window.filaPDF.push({
                imgData: imgCortada.url,
                imgW: imgCortada.width,   
                imgH: imgCortada.height,  
                larg: largFormatada,
                comp: compFormatada,
                esp: espFormatada,
                qtd: window.dadosRelatorio.totalPecas,
                vol: window.dadosRelatorio.volTotal
            });

            document.getElementById('contador_pdf').innerText = window.filaPDF.length;
        };

        window.limparFila = function() {
            window.filaPDF = [];
            document.getElementById('contador_pdf').innerText = "0";
        };

        // FUNÇÃO PRINCIPAL PARA ATUALIZAR 3D
        window.atualizarPalete = function() {
            grupoPalete.clear();

            const bLarg = parseFloat(document.getElementById('b_larg').value);
            const bComp = parseFloat(document.getElementById('b_comp').value);
            const bAlt = parseFloat(document.getElementById('b_alt').value);
            const bRecuo = parseFloat(document.getElementById('b_recuo').value) || 0; 

            const fLarg = parseFloat(document.getElementById('f_larg').value);
            const fComp = parseFloat(document.getElementById('f_comp').value);
            const fAlt = parseFloat(document.getElementById('f_alt').value);

            const pLarg = parseFloat(document.getElementById('p_larg').value);
            const pComp = parseFloat(document.getElementById('p_comp').value);
            const pAlt = parseFloat(document.getElementById('p_alt').value);

            const qtdCamadas = parseInt(document.getElementById('camadas').value);

            // --- 1. PONTALETES A 90 GRAUS (CRUZANDO A LARGURA) ---
            const geoBarrote = new THREE.BoxGeometry(bComp, bAlt, bLarg);
            const posYBarrote = bAlt / 2;
            
            const posZTras = -(fComp / 2) + (bLarg / 2) + bRecuo;
            const posZFrente = (fComp / 2) - (bLarg / 2) - bRecuo;

            const barroteTras = new THREE.Mesh(geoBarrote, matBarrote);
            barroteTras.position.set(0, posYBarrote, posZTras);
            barroteTras.castShadow = true;
            barroteTras.receiveShadow = true;
            
            const barroteCentro = new THREE.Mesh(geoBarrote, matBarrote);
            barroteCentro.position.set(0, posYBarrote, 0);
            barroteCentro.castShadow = true;
            barroteCentro.receiveShadow = true;
            
            const barroteFrente = new THREE.Mesh(geoBarrote, matBarrote);
            barroteFrente.position.set(0, posYBarrote, posZFrente);
            barroteFrente.castShadow = true;
            barroteFrente.receiveShadow = true;

            grupoPalete.add(barroteTras, barroteCentro, barroteFrente);

            // --- 2. FORRO INFERIOR ---
            const geoForro = new THREE.BoxGeometry(fLarg, fAlt, fComp);
            const forroInferior = new THREE.Mesh(geoForro, matForro);
            const posYForroInf = bAlt + (fAlt / 2);
            forroInferior.position.set(0, posYForroInf, 0);
            forroInferior.castShadow = true;
            forroInferior.receiveShadow = true;
            adicionarContorno(forroInferior);
            grupoPalete.add(forroInferior);

            // --- 3. PRODUTOS ---
            let totalPecas = 0;
            let alturaTotalProdutos = 0;
            
            if (pLarg > 0 && pComp > 0 && pAlt > 0) {
                const colunasX = Math.floor(fLarg / pLarg);
                const linhasZ = Math.floor(fComp / pComp);
                const espacoOcupadoX = colunasX * pLarg;
                const espacoOcupadoZ = linhasZ * pComp;
                const inicioX = -(espacoOcupadoX / 2) + (pLarg / 2);
                const inicioZ = -(espacoOcupadoZ / 2) + (pComp / 2);

                const geoProduto = new THREE.BoxGeometry(pLarg, pAlt, pComp);
                alturaTotalProdutos = qtdCamadas * pAlt;

                for (let camada = 0; camada < qtdCamadas; camada++) {
                    let posYProduto = bAlt + fAlt + (pAlt / 2) + (camada * pAlt);

                    for (let z = 0; z < linhasZ; z++) {
                        for (let x = 0; x < colunasX; x++) {
                            const produto = new THREE.Mesh(geoProduto, matProduto);
                            const posXP = inicioX + (x * pLarg);
                            const posZP = inicioZ + (z * pComp);
                            
                            produto.position.set(posXP, posYProduto, posZP);
                            produto.castShadow = true;
                            produto.receiveShadow = true;
                            adicionarContorno(produto); 
                            
                            grupoPalete.add(produto);
                            totalPecas++; 
                        }
                    }
                }
            }

            // --- 4. FORRO SUPERIOR ---
            const forroSuperior = new THREE.Mesh(geoForro, matForro);
            const posYForroSup = bAlt + fAlt + alturaTotalProdutos + (fAlt / 2);
            forroSuperior.position.set(0, posYForroSup, 0);
            forroSuperior.castShadow = true;
            forroSuperior.receiveShadow = true;
            adicionarContorno(forroSuperior);
            grupoPalete.add(forroSuperior);

            // --- 5. CÁLCULO DOS DADOS ---
            const alturaTotalCalculada = bAlt + fAlt + alturaTotalProdutos + fAlt;
            const alturaEmCm = alturaTotalCalculada * 100; 
            
            const volUnitario = pLarg * pComp * pAlt;
            const volTotal = volUnitario * totalPecas;

            window.dadosRelatorio.totalPecas = totalPecas;
            window.dadosRelatorio.volTotal = volTotal;

            document.getElementById('resultado-dados').innerHTML = `
                <b>Altura Total:</b> ${alturaTotalCalculada.toFixed(3)} m <span style="font-size: 12px; color: #555;">(${alturaEmCm.toFixed(1)} cm)</span><br>
                <hr>
                <b>Total de Peças:</b> ${totalPecas} un<br>
                <b>Vol. Unitário:</b> ${volUnitario.toFixed(5)} m³<br>
                <b>Vol. Total:</b> ${volTotal.toFixed(5)} m³
            `;
        };

        // FUNÇÃO PARA GERAR O PDF (NOVO LAYOUT 2x2 E FORMATO DE DIMENSÃO OTIMIZADO)
        window.gerarPDF = async function() {
            if(window.filaPDF.length === 0) {
                await window.adicionarFila();
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('l', 'mm', 'a4'); // 'l' = landscape
            const pageWidth = 297; 

            let nomeProduto = document.getElementById('nome_produto').value.trim();
            if(!nomeProduto) nomeProduto = "PEÇAS CORTADAS DE MDF";

            // Título Principal
            doc.setFont("helvetica", "bold");
            doc.setFontSize(22);
            doc.text(nomeProduto.toUpperCase(), pageWidth / 2, 20, { align: 'center' });

            const qtdItens = window.filaPDF.length;

            for(let i = 0; i < qtdItens; i++) {
                const item = window.filaPDF[i];
                let centroX, linhaY;
                let maxImgW = 125; 

                // Lógica de posicionamento (2 em cima, 1 embaixo centralizado)
                if (qtdItens === 1) {
                    centroX = pageWidth / 2;
                    linhaY = 40;
                    maxImgW = 160;
                } else if (qtdItens === 2) {
                    centroX = i === 0 ? (pageWidth / 4) : (pageWidth / 4) * 3;
                    linhaY = 40;
                } else if (qtdItens === 3) {
                    if (i === 0) {
                        centroX = pageWidth / 4;
                        linhaY = 32;
                    } else if (i === 1) {
                        centroX = (pageWidth / 4) * 3;
                        linhaY = 32;
                    } else if (i === 2) {
                        centroX = pageWidth / 2;
                        linhaY = 118; 
                    }
                }

                // DIMENSÃO (Tudo na mesma linha: Espessura X Largura X Comprimento)
                doc.setFont("helvetica", "bold");
                doc.setFontSize(11);
                doc.text(`DIMENSÃO: ${item.esp} X ${item.larg} X ${item.comp}`, centroX, linhaY, { align: 'center' });

                // QUANT. RÉGUAS
                linhaY += 8; 
                doc.text(`QUANT. RÉGUAS: ${item.qtd}`, centroX, linhaY, { align: 'center' });

                // M³ TOTAL
                linhaY += 8;
                let volFormatado = item.vol.toFixed(5).replace('.', ',');
                doc.text(`M³ TOTAL: ${volFormatado}`, centroX, linhaY, { align: 'center' });

                linhaY += 8; // Espaço mais curto antes da imagem
                
                // INSERINDO A IMAGEM EXTREMAMENTE OTIMIZADA E GRANDE
                const canvasW = item.imgW;
                const canvasH = item.imgH;
                let imgH = (canvasH * maxImgW) / canvasW;

                // Como removemos a grade e as margens, a imagem vai tentar ficar do tamanho máximo possível
                if (qtdItens === 3 && imgH > 68) {
                    imgH = 68;
                    maxImgW = (canvasW * imgH) / canvasH;
                } else if (qtdItens < 3 && imgH > 120) {
                    imgH = 120;
                    maxImgW = (canvasW * imgH) / canvasH;
                }

                doc.addImage(item.imgData, 'PNG', centroX - (maxImgW / 2), linhaY, maxImgW, imgH);
            }

            doc.save(`Relatorio_PCP_${nomeProduto.replace(/ /g, "_")}.pdf`);
            
            window.limparFila();
        };

        window.atualizarPalete();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
